---
import Badge from "./Badge.astro";
interface Props {
  title: string;
  content: string;
  imageNumber: number;
  badges: string[];
}

const { title, content, imageNumber, badges } = Astro.props;
---

<project-entry
  class="w-full lg:w-2/3 min-h-[50vh] lg:h-screen flex flex-col project"
  data-image={imageNumber}
>
  <div class="my-auto">
    <h2 class="text-3xl lg:text-5xl font-playfair font-bold text-cinnabar-700">
      {title}
    </h2>
    <div class="flex flex-row flex-wrap mt-4">
      {badges.map((badge) => <Badge text={badge} />)}
    </div>
    <p class="text-justify mt-4 font-roboto text-cinnabar-600 text-lg">
      {content}
    </p>
  </div>
</project-entry>

<script>
  class ProjectEntry extends HTMLElement {
    observer: IntersectionObserver | undefined;
    imageNumber: string;
    image: NodeListOf<HTMLImageElement>;
    imageWrapper: NodeListOf<HTMLDivElement>;
    margin: string = "-20% 0px -80% 0px";
    static desktopWidth = 1024;
    static desktopMargin = "-20% 0px -80% 0px";
    static mobileMargin = "0px 0px -50% 0px";
    constructor() {
      super();

      this.imageNumber = this.dataset.image ?? "0";

      this.imageWrapper = document.querySelectorAll(
        `.project-image-wrapper-${this.imageNumber}`
      ) as NodeListOf<HTMLDivElement>;

      this.image = document.querySelectorAll(
        `.project-image-${this.imageNumber}`
      ) as NodeListOf<HTMLImageElement>;

      this.setUpObserver();

      window.addEventListener("resize", () => {
        if (this.observer) this.observer.disconnect();
        this.setUpObserver();
      });
    }

    private setUpObserver() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (!entry.isIntersecting) {
              if (
                window.innerWidth >= ProjectEntry.desktopWidth ||
                this.imageNumber !== "0"
              ) {
                this.imageWrapper.forEach((imageWrapper) => {
                  imageWrapper.classList.remove("opacity-100");
                  imageWrapper.classList.add("opacity-0");
                });
              }
              this.image.forEach((image) => {
                image.classList.remove("scale-100");
                image.classList.add("scale-125");
              });
            } else {
              if (window.innerWidth >= 1024 || this.imageNumber !== "0") {
                this.imageWrapper.forEach((imageWrapper) => {
                  imageWrapper.classList.add("opacity-100");
                  imageWrapper.classList.remove("opacity-0");
                });
              }
              this.image.forEach((image) => {
                image.classList.add("scale-100");
                image.classList.remove("scale-125");
              });
            }
          });
        },
        {
          rootMargin:
            window.innerWidth >= ProjectEntry.desktopWidth
              ? ProjectEntry.desktopMargin
              : ProjectEntry.mobileMargin,
        }
      );

      this.observer.observe(this);
    }
  }

  customElements.define("project-entry", ProjectEntry);
</script>
